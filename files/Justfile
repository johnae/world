## This is also wrapped up into the command "world" which is available
## anywhere - even outside this repo. See: utils/world.nix

set shell := ["nu", "-c"]

alias help := default

import? '~/.just/world.extras.just'
import? '/home/john/Development/world/.just/world.extras.just'

default:
  #!/usr/bin/env nu
  just --list -f {{justfile()}} -d {{invocation_directory()}}
  if (echo {{invocation_directory()}} | str contains "world") {
    print "\nPrivate (in repo only):"
    awk -F ':| ' '/^\[private\]/ { in_private = 1; next} /^(^\[private\])/ { in_private = 0 } in_private && /^[a-z]/ { print "    "$1 }' {{justfile()}}
  }

# search for packages
search query:
  @nix search nixpkgs {{query}} --json | from json | transpose | flatten | select column0 version description | rename --column { column0: attribute }

# open a shell with given packages available
shell +args:
  @nix shell (echo '{{args}}' | each { |it| if ($it | str contains '#') { $it } else { $"nixpkgs#($it)" } } )

# open a shell with given packages available allowing unfree packages
shell-unfree +args:
  @with-env {NIXPKGS_ALLOW_UNFREE: 1} { nix shell --impure (echo '{{args}}' | each { |it| if ($it | str contains '#') { $it } else { $"nixpkgs#($it)" } } ) }

# garbage collect the system
gc:
  @nix-collect-garbage -d

cachix +args:
  with-env [CACHIX_SIGNING_KEY (rbw get cachix)] { cachix push insane {{args}} }

# upgrade the system using given flake ref
[macos]
upgrade flake="github:johnae/world":
  @rm -rf ~/.cache/nix/fetcher-cache-v1.sqlite*
  @sudo darwin-rebuild switch --flake '{{flake}}'

# upgrade the system using given flake ref
[linux]
upgrade flake="github:johnae/world":
  #!/usr/bin/env nu
  rm -rf ~/.cache/nix/fetcher-cache-v1.sqlite*
  open /etc/os-release
    | lines
    | parse "{key}={value}"
    | where key == "ID"
    | get value
    | first
    | if $in == "nixos" {
      nixos-rebuild boot --flake '{{flake}}' --sudo -L
      if (echo initrd kernel kernel-modules | all { |it| (readlink $"/run/booted-system/($it)") != (readlink $"/nix/var/nix/profiles/system/($it)") }) { echo "The system must be rebooted for the changes to take effect" } else { nixos-rebuild switch --flake '{{flake}}' --sudo -L }
    } else {
      home-manager switch --flake '{{flake}}' --impure
    }

# build the system using given flake ref
[macos]
build flake="github:johnae/world":
  @darwin-rebuild build --flake '{{flake}}'

# build the system using given flake ref
[linux]
build flake="github:johnae/world":
  #!/usr/bin/env nu
  open /etc/os-release
    | lines
    | parse "{key}={value}"
    | where key == "ID"
    | get value
    | first
    | if $in == "nixos" {
      nixos-rebuild build --flake '{{flake}}' -L
    } else {
      home-manager build --flake '{{flake}}' -L --impure
    }

[linux]
build-installer flake="github:johnae/world":
  @nix build '{{flake}}#nixosConfigurations.installer.config.system.build.isoImage'

[private]
remote-reset-all:
  #!/usr/bin/env bash
  CURLCREDS="$(rbw get hetzner --full webservice-password | grep user: | awk '{print $2}'):$(rbw get hetzner webservice-password)"
  CURLEP=https://robot-ws.your-server.de
  FINGERPRINT="$(ssh-keygen -E md5 -lf ~/.ssh/id_ed25519_alt | awk '{print $2}' | sed 's|MD5:||g')"
  function hetzner() {
    local path="$1"
    shift
    curl -u "$CURLCREDS" "$@" "$CURLEP/$path"
  }
  for server_number in $(hetzner /server | jq -r .[].server.server_number); do
    hetzner "/boot/$server_number/rescue" -d "os=linux&authorized_key[]=$FINGERPRINT"
    hetzner "/reset/$server_number" -d "type=hw"
  done

[private]
remote-reset name:
  #!/usr/bin/env bash
  CURLCREDS="$(rbw get hetzner --full webservice-password | grep user: | awk '{print $2}'):$(rbw get hetzner webservice-password)"
  CURLEP=https://robot-ws.your-server.de
  FINGERPRINT="$(ssh-keygen -E md5 -lf ~/.ssh/id_ed25519_alt | awk '{print $2}' | sed 's|MD5:||g')"
  function hetzner() {
    local path="$1"
    shift
    curl -u "$CURLCREDS" "$@" "$CURLEP/$path"
  }
  server_number=$(hetzner /server | jq -r '.[] | select(.server.server_name == "{{name}}").server.server_number')
  echo "reset to rescue system {{name}}, server_number: $server_number"
  hetzner "/boot/$server_number/rescue" -d "os=linux&authorized_key[]=$FINGERPRINT"
  hetzner "/reset/$server_number" -d "type=hw"

[private]
remote-reboot name:
  #!/usr/bin/env bash
  CURLCREDS="$(rbw get hetzner --full webservice-password | grep user: | awk '{print $2}'):$(rbw get hetzner webservice-password)"
  CURLEP=https://robot-ws.your-server.de
  FINGERPRINT="$(ssh-keygen -E md5 -lf ~/.ssh/id_ed25519_alt | awk '{print $2}' | sed 's|MD5:||g')"
  function hetzner() {
    local path="$1"
    shift
    curl -u "$CURLCREDS" "$@" "$CURLEP/$path"
  }
  server_number=$(hetzner /server | jq -r '.[] | select(.server.server_name == "{{name}}").server.server_number')
  echo "rebooting {{name}}, server_number: $server_number"
  hetzner "/reset/$server_number" -d "type=hw"

[private]
remote-upgrade flake-config ssh-host:
  #!/usr/bin/env bash
  set -euo pipefail
  nixos-rebuild switch --flake '{{flake-config}}' --target-host {{ssh-host}} --sudo

# Generic remote NixOS installation using nixos-anywhere
# Configurable via environment variables for flexibility across different setups
#
# Required environment variables (when encrypt-disk=yes):
#   SSH_HOST_KEY_CMD       - Command to retrieve SSH host key
#   SSH_INITRD_KEY_CMD     - Command to retrieve initrd SSH key
#   DISK_PASSWORD_CMD      - Command to retrieve disk encryption password
#
# Optional environment variables:
#   SSH_HOST_KEY_PATH              - Destination path for SSH host key (relative, no leading slash)
#                                    (default: etc/ssh/ssh_host_ed25519_key → /etc/ssh/ssh_host_ed25519_key)
#   SSH_INITRD_KEY_PATH            - Destination path for initrd SSH key (relative, no leading slash)
#                                    (default: etc/ssh/initrd_ed25519_key → /etc/ssh/initrd_ed25519_key)
#   SSH_IDENTITY_FILE              - SSH key for connecting to target (e.g., ~/.ssh/id_ed25519)
#   TAILSCALE_OAUTH_CLIENT_ID      - Tailscale OAuth client ID (enables Tailscale integration)
#   TAILSCALE_OAUTH_CLIENT_SECRET  - Tailscale OAuth client secret (enables Tailscale integration)
#   TAILSCALE_TAILNET              - Tailscale tailnet name (default: 9000.dev)
#   TAILSCALE_DEVICE_TAG           - Tailscale device tag (default: tag:server)
#   PRECMD_K8S_CLEANUP             - Set to "yes" to enable k8s device cleanup (requires K8S_API_HOSTNAME)
#   K8S_API_HOSTNAME               - Kubernetes API hostname for device cleanup
#
# Example: Using age-encrypted files (like icarus pattern)
#   export SSH_IDENTITY_FILE="$HOME/.ssh/id_ed25519"
#   export SSH_HOST_KEY_CMD="rage -d -i identity.txt secrets/icarus/id_ed25519_host_key.age"
#   export SSH_INITRD_KEY_CMD="rage -d -i identity.txt secrets/icarus/id_ed25519_initrd_key.age"
#   export SSH_INITRD_KEY_PATH="keep/secrets/initrd_ed25519_key"  # icarus uses /keep/secrets
#   export DISK_PASSWORD_CMD="rage -d -i identity.txt secrets/icarus/disk_password.age"
#   just remote-install .#icarus root@192.168.1.100
#
# Example: Using plain files (less secure, but simple)
#   export SSH_HOST_KEY_CMD="cat /secure/keys/ssh_host_ed25519_key"
#   export SSH_INITRD_KEY_CMD="cat /secure/keys/initrd_ed25519_key"
#   export DISK_PASSWORD_CMD="cat /secure/keys/disk_password.txt"
#   just remote-install .#myhost root@192.168.1.100
#
# Example: No disk encryption
#   just remote-install .#myhost root@192.168.1.100 no
#
# Example: With Tailscale but no k8s cleanup
#   export SSH_HOST_KEY_CMD="rbw get myproject ssh_host_key"
#   export SSH_INITRD_KEY_CMD="rbw get myproject ssh_initrd_key"
#   export DISK_PASSWORD_CMD="rbw get myproject disk_password"
#   export TAILSCALE_OAUTH_CLIENT_ID="$(rbw get tailscale client_id)"
#   export TAILSCALE_OAUTH_CLIENT_SECRET="$(rbw get tailscale client_secret)"
#   export TAILSCALE_TAILNET="example.com"
#   just remote-install .#myhost root@192.168.1.100
# 
#
[private]
remote-install flake-config ssh-host encrypt-disk="yes" precmd="":
  #!/usr/bin/env bash
  set -x
  set -euo pipefail

  # Validate required environment variables
  if [ "{{encrypt-disk}}" = "yes" ]; then
    if [ -z "${SSH_HOST_KEY_CMD:-}" ]; then
      echo "ERROR: SSH_HOST_KEY_CMD environment variable is required when encrypt-disk=yes"
      echo ""
      echo "Examples:"
      echo "  export SSH_HOST_KEY_CMD='rbw get hetzner cloud_ssh_host_key | base64 -d'"
      echo "  export SSH_HOST_KEY_CMD='rage -d secrets/host_key.age'"
      echo "  export SSH_HOST_KEY_CMD='cat /path/to/ssh_host_ed25519_key'"
      exit 1
    fi
    if [ -z "${SSH_INITRD_KEY_CMD:-}" ]; then
      echo "ERROR: SSH_INITRD_KEY_CMD environment variable is required when encrypt-disk=yes"
      echo ""
      echo "Examples:"
      echo "  export SSH_INITRD_KEY_CMD='rbw get hetzner cloud_ssh_initrd_key | base64 -d'"
      echo "  export SSH_INITRD_KEY_CMD='rage -d secrets/initrd_key.age'"
      echo "  export SSH_INITRD_KEY_CMD='cat /path/to/initrd_ed25519_key'"
      exit 1
    fi
    if [ -z "${DISK_PASSWORD_CMD:-}" ]; then
      echo "ERROR: DISK_PASSWORD_CMD environment variable is required when encrypt-disk=yes"
      echo ""
      echo "Examples:"
      echo "  export DISK_PASSWORD_CMD='rbw get hetzner disk_password'"
      echo "  export DISK_PASSWORD_CMD='rage -d secrets/disk_password.age'"
      echo "  export DISK_PASSWORD_CMD='cat /path/to/disk_password.txt'"
      exit 1
    fi
  fi

  temp="$(mktemp -d)"
  disktmp="$(mktemp -d)"
  hostname="$(echo '{{flake-config}}' | awk -F'#' '{print $2}')"
  cleanup() {
    echo cleaning up tmp files in "$temp" and "$disktmp"
    rm -rf "$temp" "$disktmp"
  }
  trap cleanup EXIT

  function port-open() {
    local retries=20
    local ip="$(echo "{{ssh-host}}" | sed 's|.*@||g')"
    local port="$1"
    while true; do
      if [ ${retries} -le 0 ]; then
        echo "Failed to unlock host"
        return 1
      fi
      retries=$((retries - 1))
      echo "Probing host ${ip} on port ${port}"
      if timeout 5 bash -c "</dev/tcp/${ip}/${port}"; then
        echo "Host ${ip} is up"
        return 0
      fi
      echo "Host ${ip} on port ${port} is not responding... retrying"
      sleep 10
    done
  }

  function unlock() {
    local ip="$(echo "{{ssh-host}}" | sed 's|.*@||g')"
    local port="2222"
    local ssh_key_arg=""
    if [ -n "${SSH_IDENTITY_FILE:-}" ]; then
      ssh_key_arg="-i ${SSH_IDENTITY_FILE}"
    fi
    if port-open "$port"; then
      echo "Host ${ip}:${port} is open, unlocking"
      eval "$DISK_PASSWORD_CMD" | ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null ${ssh_key_arg} -p "${port}" "{{ssh-host}}" || true
      return 0
    fi
    return 1
  }

  # Set default key paths (can be overridden via env vars)
  SSH_HOST_KEY_PATH="${SSH_HOST_KEY_PATH:-etc/ssh/ssh_host_ed25519_key}"
  SSH_INITRD_KEY_PATH="${SSH_INITRD_KEY_PATH:-etc/ssh/initrd_ed25519_key}"
  TAILSCALE_AUTH_KEY_PATH="${TAILSCALE_AUTH_KEY_PATH:-etc/tailscale-auth-key}"

  # Create necessary directories for key paths
  install -d -m755 "$temp/$(dirname "$SSH_HOST_KEY_PATH")"
  install -d -m755 "$temp/$(dirname "$SSH_INITRD_KEY_PATH")"
  install -d -m755 "$temp/$(dirname "$TAILSCALE_AUTH_KEY_PATH")"

  # Optional Tailscale integration (auto-detect based on env var presence)
  if [ -n "${TAILSCALE_OAUTH_CLIENT_ID:-}" ] && [ -n "${TAILSCALE_OAUTH_CLIENT_SECRET:-}" ]; then
    echo "Tailscale credentials detected, setting up Tailscale integration"
    TAILSCALE_TAILNET="${TAILSCALE_TAILNET:-9000.dev}"
    TAILSCALE_DEVICE_TAG="${TAILSCALE_DEVICE_TAG:-tag:server}"

    TS_TOKEN="$(curl -s \
      -d "client_id=${TAILSCALE_OAUTH_CLIENT_ID}" \
      -d "client_secret=${TAILSCALE_OAUTH_CLIENT_SECRET}" \
      "https://api.tailscale.com/api/v2/oauth/token" | jq -r .access_token)"

    OLD_DEVICE_ID="$(curl "https://api.tailscale.com/api/v2/tailnet/${TAILSCALE_TAILNET}/devices" --header "Authorization: Bearer $TS_TOKEN" | jq -r ".devices[] | select(.hostname == \"$hostname\").id")"

    if [[ ${#OLD_DEVICE_ID} -gt 10 ]]; then
      echo "deleting old tailscale device host: $hostname id: $OLD_DEVICE_ID"
      curl "https://api.tailscale.com/api/v2/device/$OLD_DEVICE_ID" \
        --request DELETE \
        --header "Authorization: Bearer $TS_TOKEN"
    fi

    # Optional k8s-specific device cleanup
    if [ "${PRECMD_K8S_CLEANUP:-no}" = "yes" ] && [ -n "${K8S_API_HOSTNAME:-}" ]; then
      K8S_DEVICE_ID="$(curl "https://api.tailscale.com/api/v2/tailnet/${TAILSCALE_TAILNET}/devices" --header "Authorization: Bearer $TS_TOKEN" | jq -r ".devices[] | select(.hostname == \"${K8S_API_HOSTNAME}\").id")"
      if [[ ${#K8S_DEVICE_ID} -gt 10 ]]; then
        echo "deleting old tailscale k8s device host: ${K8S_API_HOSTNAME} id: $K8S_DEVICE_ID"
        curl "https://api.tailscale.com/api/v2/device/$K8S_DEVICE_ID" \
          --request DELETE \
          --header "Authorization: Bearer $TS_TOKEN"
      fi
    fi

    curl "https://api.tailscale.com/api/v2/tailnet/${TAILSCALE_TAILNET}/keys?all=true" \
      -X POST \
      -H "Authorization: Bearer $TS_TOKEN" \
      -H 'Content-Type: application/json' \
      --data "{
       \"keyType\": \"\",
       \"description\": \"tmp\",
       \"capabilities\": {
         \"devices\": {
           \"create\": {
             \"reusable\": false,
             \"ephemeral\": false,
             \"preauthorized\": true,
             \"tags\": [
               \"${TAILSCALE_DEVICE_TAG}\"
             ]
           }
         }
       },
       \"expirySeconds\": 3600,
       \"scopes\": [
         \"all:read\"
       ],
       \"tags\": [
         \"${TAILSCALE_DEVICE_TAG}\"
       ]
      }" | jq -r .key > "$temp/$TAILSCALE_AUTH_KEY_PATH"

    chmod 0600 "$temp/$TAILSCALE_AUTH_KEY_PATH"
  else
    echo "Tailscale credentials not provided, skipping Tailscale integration"
  fi

  # Retrieve SSH keys using configured commands
  if [ "{{encrypt-disk}}" = "yes" ]; then
    eval "$SSH_HOST_KEY_CMD" > "$temp/$SSH_HOST_KEY_PATH"
    eval "$SSH_INITRD_KEY_CMD" > "$temp/$SSH_INITRD_KEY_PATH"
    eval "$DISK_PASSWORD_CMD" > "$disktmp/disk.key"
    chmod 0600 "$temp/$SSH_HOST_KEY_PATH"
    chmod 0600 "$temp/$SSH_INITRD_KEY_PATH"
  fi

  if ! port-open 22; then
    echo "port 22 on ${ip} didn't open, even after waiting a while"
    exit 1
  fi

  if [ -n "{{precmd}}" ]; then
    echo "run: {{precmd}}"
    ssh -o UserKnownHostsFile=/dev/null -o strictHostKeyChecking=no {{ssh-host}} "echo lsblk before; lsblk; {{precmd}}; echo lsblk after; lsblk; ls /dev"
  fi

  echo start installation
  if [ "{{encrypt-disk}}" = "yes" ]; then
    echo "starting remote install WITH encrypted disks"
    nix run github:nix-community/nixos-anywhere -- --disk-encryption-keys /tmp/disk.key "$disktmp/disk.key" --extra-files "$temp" --flake '{{flake-config}}' --target-host {{ssh-host}}
  else
    echo "starting remote install NO encrypted disks"
    nix run github:nix-community/nixos-anywhere -- --extra-files "$temp" --flake '{{flake-config}}' --target-host {{ssh-host}}
  fi

  unlock

[private]
remote-install-hetzner flake-config ssh-host encrypt-disk="yes" precmd="":
  #!/usr/bin/env bash
  # Wrapper that preserves the old Hetzner-specific behavior
  # Sets up all the Hetzner-specific environment variables and calls remote-install
  export SSH_IDENTITY_FILE="/home/john/.ssh/id_ed25519_alt"
  export SSH_HOST_KEY_CMD="rbw get hetzner cloud_ssh_host_key | base64 -d"
  export SSH_HOST_KEY_PATH="etc/ssh/ssh_host_ed25519_key"
  export SSH_INITRD_KEY_CMD="rbw get hetzner cloud_ssh_initrd_key | base64 -d"
  export SSH_INITRD_KEY_PATH="etc/ssh/initrd_ed25519_key"
  export DISK_PASSWORD_CMD="rbw get hetzner disk_password"
  export TAILSCALE_TAILNET="9000.dev"
  export TAILSCALE_OAUTH_CLIENT_ID="$(rbw get tailscale --full tskey-oauth-full-access | grep 'client_id:' | awk '{print $2}')"
  export TAILSCALE_OAUTH_CLIENT_SECRET="$(rbw get tailscale tskey-oauth-full-access)"
  export TAILSCALE_DEVICE_TAG="tag:server"
  export PRECMD_K8S_CLEANUP="no"
  export K8S_API_HOSTNAME="k8s-api-5df5"

  just -f {{justfile()}} -d {{invocation_directory()}} remote-install "{{flake-config}}" "{{ssh-host}}" "{{encrypt-disk}}" "{{precmd}}"

[private]
rekey:
  #!/usr/bin/env bash
  set -euo pipefail
  GITROOT="$(git rev-parse --show-toplevel)"
  cd "$GITROOT"
  RULES="$(mktemp /tmp/XXXXXX.secrets.nix)"
  export RULES
  trap 'rm -f $RULES' EXIT
  if [ ! -e identity.txt ] && [ -d secrets ]; then
    cd secrets
  else
    echo No identity.txt found and no secrets directory
    exit 1
  fi
  if [ ! -e identity.txt ]; then
    echo identity.txt missing from secrets dir
    echo please generate it using age-plugin-yubikey
    exit 1
  fi
  nix eval --file secrets.nix > "$RULES"
  agenix -i identity.txt -r

[private]
echo +args:
  @echo '{{args}}'

[private]
gh-release-update:
  ./misc/gh-release-update.nu

[private]
lint:
  #!/usr/bin/env bash
  echo '-------- [Linting] ---------'
  if ! statix check .; then
    echo "Linting failed"
    exit 1
  fi
  echo "Lint ok"

[private]
dead:
  #!/usr/bin/env bash
  echo '-------- [Check for dead code] ---------'
  if ! deadnix -f .; then
    echo "Dead code check failed"
    exit 1
  fi
  echo "No dead code"

[private]
dscheck:
  #!/usr/bin/env bash
  echo '-------- [Flake checker] ---------'
  if ! nix run github:DeterminateSystems/flake-checker; then
    echo "Flake checker failed"
    exit 1
  fi
  echo "Flake is good"

[private]
check:
  @nix flake check --impure # impure because of devenv
