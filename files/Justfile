## This is also wrapped up into the command "world" which is available
## anywhere - even outside this repo. See: utils/world.nix

set shell := ["nu", "-c"]

alias help := default

import? '~/.just/world.extras.just'
import? '/home/john/Development/world/.just/world.extras.just'

default:
  #!/usr/bin/env nu
  just --list -f {{justfile()}} -d {{invocation_directory()}}
  if (echo {{invocation_directory()}} | str contains "world") {
    print "\nPrivate (in repo only):"
    awk -F ':| ' '/^\[private\]/ { in_private = 1; next} /^(^\[private\])/ { in_private = 0 } in_private && /^[a-z]/ { print "    "$1 }' {{justfile()}}
  }

# search for packages
search query:
  @nix search nixpkgs {{query}} --json | from json | transpose | flatten | select column0 version description | rename --column { column0: attribute }

# open a shell with given packages available
shell +args:
  @nix shell (echo '{{args}}' | each { |it| if ($it | str contains '#') { $it } else { $"nixpkgs#($it)" } } )

# open a shell with given packages available allowing unfree packages
shell-unfree +args:
  @with-env {NIXPKGS_ALLOW_UNFREE: 1} { nix shell --impure (echo '{{args}}' | each { |it| if ($it | str contains '#') { $it } else { $"nixpkgs#($it)" } } ) }

# garbage collect the system
gc:
  @nix-collect-garbage -d

cachix +args:
  with-env [CACHIX_SIGNING_KEY (rbw get cachix)] { cachix push insane {{args}} }

# upgrade the system using given flake ref
[macos]
upgrade flake="github:johnae/world":
  @rm -rf ~/.cache/nix/fetcher-cache-v1.sqlite*
  @sudo darwin-rebuild switch --flake '{{flake}}'

# upgrade the system using given flake ref
[linux]
upgrade flake="github:johnae/world":
  #!/usr/bin/env nu
  rm -rf ~/.cache/nix/fetcher-cache-v1.sqlite*
  open /etc/os-release
    | lines
    | parse "{key}={value}"
    | where key == "ID"
    | get value
    | first
    | if $in == "nixos" {
      nixos-rebuild boot --flake '{{flake}}' --sudo -L
      if (echo initrd kernel kernel-modules | all { |it| (readlink $"/run/booted-system/($it)") != (readlink $"/nix/var/nix/profiles/system/($it)") }) { echo "The system must be rebooted for the changes to take effect" } else { nixos-rebuild switch --flake '{{flake}}' --sudo -L }
    } else {
      home-manager switch --flake '{{flake}}' --impure
    }

# build the system using given flake ref
[macos]
build flake="github:johnae/world":
  @darwin-rebuild build --flake '{{flake}}'

# build the system using given flake ref
[linux]
build flake="github:johnae/world":
  #!/usr/bin/env nu
  open /etc/os-release
    | lines
    | parse "{key}={value}"
    | where key == "ID"
    | get value
    | first
    | if $in == "nixos" {
      nixos-rebuild build --flake '{{flake}}' -L
    } else {
      home-manager build --flake '{{flake}}' -L --impure
    }

[linux]
build-installer flake="github:johnae/world":
  @nix build '{{flake}}#nixosConfigurations.installer.config.system.build.isoImage'

[private]
remote-reset-all:
  #!/usr/bin/env bash
  CURLCREDS="$(rbw get hetzner --full webservice-password | grep user: | awk '{print $2}'):$(rbw get hetzner webservice-password)"
  CURLEP=https://robot-ws.your-server.de
  FINGERPRINT="$(ssh-keygen -E md5 -lf ~/.ssh/id_ed25519_alt | awk '{print $2}' | sed 's|MD5:||g')"
  function hetzner() {
    local path="$1"
    shift
    curl -u "$CURLCREDS" "$@" "$CURLEP/$path"
  }
  for server_number in $(hetzner /server | jq -r .[].server.server_number); do
    hetzner "/boot/$server_number/rescue" -d "os=linux&authorized_key[]=$FINGERPRINT"
    hetzner "/reset/$server_number" -d "type=hw"
  done

[private]
remote-reset name:
  #!/usr/bin/env bash
  CURLCREDS="$(rbw get hetzner --full webservice-password | grep user: | awk '{print $2}'):$(rbw get hetzner webservice-password)"
  CURLEP=https://robot-ws.your-server.de
  FINGERPRINT="$(ssh-keygen -E md5 -lf ~/.ssh/id_ed25519_alt | awk '{print $2}' | sed 's|MD5:||g')"
  function hetzner() {
    local path="$1"
    shift
    curl -u "$CURLCREDS" "$@" "$CURLEP/$path"
  }
  server_number=$(hetzner /server | jq -r '.[] | select(.server.server_name == "{{name}}").server.server_number')
  echo "reset to rescue system {{name}}, server_number: $server_number"
  hetzner "/boot/$server_number/rescue" -d "os=linux&authorized_key[]=$FINGERPRINT"
  hetzner "/reset/$server_number" -d "type=hw"

[private]
remote-reboot name:
  #!/usr/bin/env bash
  CURLCREDS="$(rbw get hetzner --full webservice-password | grep user: | awk '{print $2}'):$(rbw get hetzner webservice-password)"
  CURLEP=https://robot-ws.your-server.de
  FINGERPRINT="$(ssh-keygen -E md5 -lf ~/.ssh/id_ed25519_alt | awk '{print $2}' | sed 's|MD5:||g')"
  function hetzner() {
    local path="$1"
    shift
    curl -u "$CURLCREDS" "$@" "$CURLEP/$path"
  }
  server_number=$(hetzner /server | jq -r '.[] | select(.server.server_name == "{{name}}").server.server_number')
  echo "rebooting {{name}}, server_number: $server_number"
  hetzner "/reset/$server_number" -d "type=hw"

[private]
remote-upgrade flake-config ssh-host:
  #!/usr/bin/env bash
  set -euo pipefail
  nixos-rebuild switch --flake '{{flake-config}}' --target-host {{ssh-host}} --sudo

[private]
remote-install flake-config ssh-host encrypt-disk="yes" precmd="":
  #!/usr/bin/env bash
  set -euo pipefail
  temp="$(mktemp -d)"
  disktmp="$(mktemp -d)"
  hostname="$(echo '{{flake-config}}' | awk -F'#' '{print $2}')"
  cleanup() {
    echo cleaning up tmp files in "$temp" and "$disktmp"
    rm -rf "$temp" "$disktmp"
  }
  trap cleanup EXIT

  function port-open() {
    local retries=20
    local ip="$(echo "{{ssh-host}}" | sed 's|.*@||g')"
    local port="$1"
    while true; do
      if [ ${retries} -le 0 ]; then
        echo "Failed to unlock host"
        return 1
      fi
      retries=$((retries - 1))
      echo "Probing host ${ip} on port ${port}"
      if timeout 5 bash -c "</dev/tcp/${ip}/${port}"; then
        echo "Host ${ip} is up"
        return 0
      fi
      echo "Host ${ip} on port ${port} is not responding... retrying"
      sleep 10
    done
  }

  function unlock() {
    local ip="$(echo "{{ssh-host}}" | sed 's|.*@||g')"
    local port="2222"
    if port-open "$port"; then
      echo "Host ${ip}:${port} is open, unlocking"
      rbw get hetzner -- disk_password | ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -i /home/john/.ssh/id_ed25519_alt -p "${port}" "{{ssh-host}}" || true
      return 0
    fi
    return 1
  }

  install -d -m755 "$temp/etc/ssh"

  TS_TOKEN="$(curl -s \
    -d "client_id=$(rbw get tailscale --full tskey-oauth-full-access | grep client_id: | awk -F': ' '{print $2}')" \
    -d "client_secret=$(rbw get tailscale tskey-oauth-full-access)" \
    "https://api.tailscale.com/api/v2/oauth/token" | jq -r .access_token)"

  OLD_DEVICE_ID="$(curl "https://api.tailscale.com/api/v2/tailnet/9000.dev/devices" --header "Authorization: Bearer $TS_TOKEN" | jq -r ".devices[] | select(.hostname == \"$hostname\").id")"
  K8S_DEVICE_ID="$(curl "https://api.tailscale.com/api/v2/tailnet/9000.dev/devices" --header "Authorization: Bearer $TS_TOKEN" | jq -r ".devices[] | select(.hostname == \"k8s-api-5df5\").id")"

  if [[ ${#OLD_DEVICE_ID} -gt 10 ]]; then
    echo "deleting old tailscale device host: $hostname id: $OLD_DEVICE_ID"
    curl "https://api.tailscale.com/api/v2/device/$OLD_DEVICE_ID" \
      --request DELETE \
      --header "Authorization: Bearer $TS_TOKEN"
  fi

  # if [[ ${#K8S_DEVICE_ID} -gt 10 ]]; then
  #   echo "deleting old tailscale device host: $hostname id: $K8S_DEVICE_ID"
  #   curl "https://api.tailscale.com/api/v2/device/$K8S_DEVICE_ID" \
  #     --request DELETE \
  #     --header "Authorization: Bearer $TS_TOKEN"
  # fi

  curl "https://api.tailscale.com/api/v2/tailnet/9000.dev/keys?all=true" \
    -X POST \
    -H "Authorization: Bearer $TS_TOKEN" \
    -H 'Content-Type: application/json' \
    --data '{
     "keyType": "",
     "description": "tmp",
     "capabilities": {
       "devices": {
         "create": {
           "reusable": false,
           "ephemeral": false,
           "preauthorized": true,
           "tags": [
             "tag:server"
           ]
         }
       }
     },
     "expirySeconds": 3600,
     "scopes": [
       "all:read"
     ],
     "tags": [
       "tag:server"
     ]
    }' | jq -r .key > "$temp/etc/tailscale-auth-key"

  chmod 0600 "$temp/etc/tailscale-auth-key"
  
  rbw get hetzner cloud_ssh_host_key | base64 -d > "$temp/etc/ssh/ssh_host_ed25519_key"
  rbw get hetzner cloud_ssh_initrd_key | base64 -d > "$temp/etc/ssh/initrd_ed25519_key"
  if [ "{{encrypt-disk}}" = "yes" ]; then
    rbw get hetzner disk_password > "$disktmp/disk.key"
  fi
  chmod 0600 "$temp/etc/ssh/ssh_host_ed25519_key"
  chmod 0600 "$temp/etc/ssh/initrd_ed25519_key"

  if ! port-open 22; then
    echo "port 22 on ${ip} didn't open, even after waiting a while"
    exit 1
  fi

  if [ -n "{{precmd}}" ]; then
    echo "run: {{precmd}}"
    ssh -o UserKnownHostsFile=/dev/null -o strictHostKeyChecking=no {{ssh-host}} "echo lsblk before; lsblk; {{precmd}}; echo lsblk after; lsblk; ls /dev"
  fi

  echo start installation
  if [ "{{encrypt-disk}}" = "yes" ]; then
    echo "starting remote install WITH encrypted disks"
    nix run github:nix-community/nixos-anywhere -- --disk-encryption-keys /tmp/disk.key "$disktmp/disk.key" --extra-files "$temp" --flake '{{flake-config}}' --target-host {{ssh-host}}
  else
    echo "starting remote install NO encrypted disks"
    nix run github:nix-community/nixos-anywhere -- --extra-files "$temp" --flake '{{flake-config}}' --target-host {{ssh-host}}
  fi

  unlock

[private]
rekey:
  #!/usr/bin/env bash
  set -euo pipefail
  GITROOT="$(git rev-parse --show-toplevel)"
  cd "$GITROOT"
  RULES="$(mktemp /tmp/XXXXXX.secrets.nix)"
  export RULES
  trap 'rm -f $RULES' EXIT
  if [ ! -e identity.txt ] && [ -d secrets ]; then
    cd secrets
  else
    echo No identity.txt found and no secrets directory
    exit 1
  fi
  if [ ! -e identity.txt ]; then
    echo identity.txt missing from secrets dir
    echo please generate it using age-plugin-yubikey
    exit 1
  fi
  nix eval --file secrets.nix > "$RULES"
  agenix -i identity.txt -r

[private]
echo +args:
  @echo '{{args}}'

[private]
gh-release-update:
  ./misc/gh-release-update.nu

[private]
lint:
  #!/usr/bin/env bash
  echo '-------- [Linting] ---------'
  if ! statix check .; then
    echo "Linting failed"
    exit 1
  fi
  echo "Lint ok"

[private]
dead:
  #!/usr/bin/env bash
  echo '-------- [Check for dead code] ---------'
  if ! deadnix -f .; then
    echo "Dead code check failed"
    exit 1
  fi
  echo "No dead code"

[private]
dscheck:
  #!/usr/bin/env bash
  echo '-------- [Flake checker] ---------'
  if ! nix run github:DeterminateSystems/flake-checker; then
    echo "Flake checker failed"
    exit 1
  fi
  echo "Flake is good"

[private]
check:
  @nix flake check --impure # impure because of devenv
