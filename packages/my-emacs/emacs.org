#+TITLE: Emacs config
#+PROPERTY: header-args :emacs-lisp :tangle yes :cache yes :results silent :comments link :exports code
#+AUTHOR: John Axel Eriksson
#+TOC: true
#+STARTUP: fninline overview

This is my emacs configuration. It's documented for my benefit. This lives within my [[https://nixos.org][Nix/NixOS]] monorepo called [[https://github.com/johnae/world][world]].

* Initialization
** First things first
***  Lexical binding
   This has to be the first line in the file. Those are the rules.
   #+BEGIN_SRC elisp
     ;; -*- lexical-binding: t; -*-
     (setq lexical-binding t)
   #+END_SRC
** Optimization
Here we do some basic optimizations to make emacs load faster and do "stuff" more efficiently.
*** Time startup
 #+BEGIN_SRC elisp
    (add-hook 'emacs-startup-hook
       (lambda ()
         (message "Started emacs in %.03fs"
             (float-time (time-subtract after-init-time before-init-time)))))
 #+END_SRC
*** Keep a reference to the actual file-name-handler.
  #+BEGIN_SRC elisp
    (defvar file-name-handler-alist-actual file-name-handler-alist)
  #+END_SRC
*** Set the file-name-handler to nil (because regexing is cpu intensive)
  #+BEGIN_SRC elisp
  (setq file-name-handler-alist nil)
  #+END_SRC
*** Increase the gc threshold significantly for faster startup
  #+BEGIN_SRC elisp
   (setq gc-cons-threshold most-positive-fixnum)
   (add-hook 'emacs-startup-hook
     (lambda ()
       (setq gc-cons-threshold 16777216 ; 16mb
             gc-cons-percentage 0.1)))
  #+END_SRC
*** The default is very low - 4k, lsp server responses are easily much larger
  #+BEGIN_SRC elisp
  (setq read-process-output-max (* 1024 1024)) ;; 1mb
  #+END_SRC
*** Reset file-name-handler-alist after initialization
  #+BEGIN_SRC elisp
  (add-hook 'after-init-hook
    (lambda ()
      (garbage-collect)
      (setq file-name-handler-alist file-name-handler-alist-actual)) t)
  #+END_SRC
*** This makes emacsclient startup faster in TUI-mode
   There's some code in ~xterm.el~ that will wait to avoid ugly flashes and such. It doesn't seem to work and I also don't really care. I'd rather not have it seem as if emacs just "hangs" for several seconds. Don't know why that happens really but disabling this has no negative effects in my use anyway (only positive).
 #+BEGIN_SRC elisp
 (setq-default xterm-query-timeout nil)
 #+END_SRC
*** Disable startup messages
  #+BEGIN_SRC elisp
    (setq
     inhibit-startup-echo-area-message t
     inhibit-startup-screen t
     initial-scratch-message nil)
  #+END_SRC
*** Disable unnecessary UI widgets etc
  #+BEGIN_SRC elisp
    (tool-bar-mode -1)
    (blink-cursor-mode -1)
    (menu-bar-mode -1)
    (setq frame-inhibit-implied-resize t) ;; don't resize gui when setting new font - affects startup time
  #+END_SRC
*** Skip loading default lib, use fundamental-mode
  #+BEGIN_SRC elisp
  (setq inhibit-default-init t
           initial-major-mode 'fundamental-mode)
#+END_SRC
*** Disable any native compilation at runtime - done by Nix
#+BEGIN_SRC elisp
(when (featurep 'nativecomp)
  (setq comp-deferred-compilation nil))
#+END_SRC
*** Use package autoloads provided by Nix
  #+BEGIN_SRC elisp
  (defvar package-quickstart t)
  #+END_SRC
*** Misc performance tweaks
**** Skip trying a second pass through auto-mode-list
   #+BEGIN_SRC elisp
   (setq auto-mode-case-fold nil)
   #+END_SRC
**** Enable so-long mode
Emacs has problems with very long lines (eg. minified js, json for example). So long helps with that.
   #+BEGIN_SRC elisp
   (global-so-long-mode 1)
   #+END_SRC
** Setup
Some basic useful settings.
*** Don't create backup files, don't create #autosave# files
   #+BEGIN_SRC elisp
   (setq temporary-file-directory "~/.emacs.d/tmp/")
   (unless (file-exists-p "~/.emacs.d/tmp")
     (make-directory "~/.emacs.d/tmp"))

   (setq backup-inhibited t
            make-backup-files nil ; don't create backup~ files
            create-lockfiles nil
            auto-save-default nil) ; don't create #autosave# files
   #+END_SRC
*** Don't confirm org-babel eval. Somewhat dangerous. I live in the fast lane.
   #+BEGIN_SRC elisp
     (setq org-confirm-babel-evaluate nil)
   #+END_SRC
*** Disable impure packages (as in not already fetched by Nix)
   #+BEGIN_SRC elisp
     (setq
        package-archives nil
        package-enable-at-startup nil
      )
   #+END_SRC
*** Include common lisp emulation functions
   #+BEGIN_SRC elisp
     (require 'cl-lib)
   #+END_SRC
*** Initialize use-package
   #+BEGIN_SRC elisp
   (eval-when-compile
     (require 'use-package))
   #+END_SRC
*** Setup auth sources
   #+BEGIN_SRC elisp
     (setq auth-sources '("~/.authinfo.gpg" "~/.authinfo" "~/.netrc"))
   #+END_SRC
*** Set utf8 everywhere
   #+BEGIN_SRC elisp
     (set-charset-priority 'unicode)
     (setq locale-coding-system 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-selection-coding-system 'utf-8)
     (prefer-coding-system 'utf-8)
     (setq default-process-coding-system '(utf-8-unix . utf-8-unix))
     (when (display-graphic-p)
       (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
   #+END_SRC
*** Set browser function - eg. which browser to open links in
   #+BEGIN_SRC elisp
     (setq browse-url-browser-function 'browse-url-generic
              browse-url-generic-program "firefox")
   #+END_SRC
*** Show trailing whitespace when programming
   #+BEGIN_SRC elisp
   (set-face-background 'trailing-whitespace "yellow")
   (add-hook 'prog-mode-hook
     (lambda ()
       (setq show-trailing-whitespace t)))
   #+END_SRC
*** I'm in Europe so I want dates to be displayed in European formats
   #+BEGIN_SRC elisp
   (setq european-date-style 'european
           calendar-set-date-style 'european
           calendar-week-start-day 1
           calendar-date-display-form
              '((if dayname
                    (concat dayname ", "))
                day " " monthname " " year))

   (setq calendar-time-display-form
         '(24-hours ":" minutes))
   #+END_SRC
*** Highlight matching parentheses
   #+BEGIN_SRC elisp
   (defun my-show-paren-mode ()
      "Enables 'show-paren-mode'."
      (setq show-paren-delay 0)
      (set-face-background 'show-paren-match (face-background 'default))
      (set-face-foreground 'show-paren-match "#def")
      (set-face-attribute 'show-paren-match nil :weight 'extra-bold)
      (show-paren-mode 1))
   (add-hook 'prog-mode-hook 'my-show-paren-mode)
   #+END_SRC
*** Enable electric pair mode
   Electric pair mode is a fancy way of saying - when inserting an opening delimiter, also insert a closing one and put me in between. Electric pair mode! Obviously.
   #+BEGIN_SRC elisp
     (add-hook 'prog-mode-hook 'electric-pair-mode)
   #+END_SRC
*** Highlight current line when programming
   #+BEGIN_SRC elisp
     (add-hook 'prog-mode-hook 'hl-line-mode)
   #+END_SRC
*** Use wl-clipboard for interprocess copy/paste
   #+BEGIN_SRC elisp
     (setq wl-copy-process nil)
     (defun wl-copy (text)
       (setq wl-copy-process (make-process :name "wl-copy"
                                           :buffer nil
                                           :command '("wl-copy" "-f" "-n")
                                           :connection-type 'pipe))
       (process-send-string wl-copy-process text)
       (process-send-eof wl-copy-process))
     (defun wl-paste ()
       (if (and wl-copy-process (process-live-p wl-copy-process))
           nil ; should return nil if we're the current paste owner
           (shell-command-to-string "wl-paste -n | tr -d \r")))
     (when (display-graphic-p)
       (setq interprogram-cut-function 'wl-copy)
       (setq interprogram-paste-function 'wl-paste)
     )
   #+END_SRC
*** Editor settings (tabs, spaces, newlines etc)
   #+BEGIN_SRC elisp
   (setq mode-require-final-newline t
            tabify nil
            tab-stop-list (number-sequence 2 120 2))
   (setq-default tab-width 2
                         indent-tabs-mode nil)
   #+END_SRC
*** Default shell to bash
   Without this (if you're otherwise using fish for example) eshell prompts can be very sluggish - if you're doing anything fancy such as git status etc.
   The problem comes from executing external commands which are run by your $SHELL. Tramp can also be negatively affected.
   #+BEGIN_SRC elisp
   (setq shell-file-name "bash")
   #+END_SRC
** Utility functions
Utility functions used here and there.
*** Returns the output of a shell command without trailing whitespace
#+BEGIN_SRC elisp
  (defun jae/shell-command-to-string-nows (cmd)
    "Return shell command output without trailing newline and whitespace."
    (replace-regexp-in-string "\n\\'" ""
      (replace-regexp-in-string "\\(\\`[[:space:]\n]*\\|[[:space:]\n]*\\'\\)" ""
        (shell-command-to-string cmd)
        )
      )
    )
#+END_SRC
*** Creates new empty numbered buffers
#+BEGIN_SRC elisp
(defun jae/new-empty-buffer ()
  "Create a new empty buffer.
New buffer will be named “untitled” or “untitled<2>”, “untitled<3>”, etc."
  (interactive)
  (let (($buf (generate-new-buffer "untitled")))
    (switch-to-buffer $buf)
    (funcall initial-major-mode)
    (setq buffer-offer-save t)
    $buf
    ))
#+END_SRC
*** Don't write custom settings anywhere
   #+BEGIN_SRC elisp
   (setq custom-file null-device)
   #+END_SRC
*** Themes aren't less safe than the rest of emacs
   #+BEGIN_SRC elisp
   (setq custom-safe-themes t)
   #+END_SRC
*** Cloud/k8s utility functions
   #+BEGIN_SRC elisp
     (defun jae/pick-kubectx ()
       "Select k8s context"
       (interactive)
       (setenv "KUBECTX_IGNORE_FZF" "y")
       (completing-read "Select kubernetes cluster: " (split-string (shell-command-to-string "kubectx") "\n" t)
                 :action '(1
                            ("o" (lambda (x) (shell-command (concat "kubectx " x))))
                          )
                 )
       )

     (defun jae/pick-kubens ()
       "Select k8s namespace"
       (interactive)
       (setenv "KUBECTX_IGNORE_FZF" "y")
       (completing-read "Select kubernetes namespace: " (split-string (shell-command-to-string "kubens") "\n" t)
                 :action '(1
                          ("o" (lambda (x) (shell-command (concat "kubens " x))))
                          )
                 )
       )

     (defun jae/pick-gcp-project ()
       "Select GCP proejct"
       (interactive)
       (completing-read "Select GCP Project: " (split-string (shell-command-to-string "gcloud projects list | tail -n +2 | awk '{print $1}'") "\n" t)
                 :action '(1
                          ("o" (lambda (x) (shell-command (concat "gcloud config set project " x))))
                          )
                 )
       )

   #+END_SRC
** User interface
*** Set the default font
#+BEGIN_SRC elisp
  (add-to-list 'default-frame-alist '(font . "JetBrainsMono Nerd Font 14"))
#+END_SRC
*** Set background alpha
#+BEGIN_SRC elisp
(set-frame-parameter (selected-frame) 'alpha '(96 . 96))
(add-to-list 'default-frame-alist '(alpha . (96 . 96)))
#+END_SRC
*** Display line numbers
   Display relative line numbers actually.
 #+BEGIN_SRC elisp
   (setq display-line-numbers-type 'relative
         display-line-numbers-current-absolute t
   )
   (add-hook 'prog-mode-hook 'display-line-numbers-mode)
 #+END_SRC
*** Tweak modeline
#+BEGIN_SRC elisp
  (add-to-list 'mode-line-misc-info (list (jae/shell-command-to-string-nows "whoami") "@" (jae/shell-command-to-string-nows "hostname") " "))
#+END_SRC
*** Tab bar tweaks
#+BEGIN_SRC elisp
  (tab-bar-mode 1)
  ;;(tab-line-mode)
  (set-face-attribute 'tab-bar-tab nil :inherit 'doom-modeline-panel :foreground nil :background nil)
  ;;(setq tab-bar-show nil)
  ;;(setq tab-bar-format 'tab-bar-format-tabs-groups)
#+END_SRC
*** Desktop save
#+BEGIN_SRC elisp
  (desktop-save-mode 1)
  (add-hook 'server-after-make-frame-hook 'desktop-read)
#+END_SRC
* Packages
Package setup.

** Performance
*** Adjust garbage collection based on activity (eg. gc on idle)
   #+BEGIN_SRC elisp
     (use-package gcmh
       :hook (after-init-hook . gcmh-mode)
       :init
       (setq gcmh-idle-delay 5
                gcmh-high-cons-threshold (* 32 1024 1024)) ; 32MB
     )
   #+END_SRC
** No littering
 #+BEGIN_SRC elisp
   (use-package no-littering)
 #+END_SRC
** Keybindings (general.el)
*** General itself
  #+BEGIN_SRC elisp
    (use-package general
      :config
      (general-evil-setup t)
      (general-create-definer jae/leader-keys
        :keymaps '(normal insert visual emacs)
        :prefix "SPC"
        :global-prefix "M-SPC"))
  #+END_SRC
*** Leader key bindings
  #+BEGIN_SRC elisp
    (jae/leader-keys
      "t" '(:ignore t :which-key "toggles")
      "tt" '(consult-theme :which-key "switch-theme")

      "<SPC>" '(:ignore p :which-key "tab")
      "<SPC><right>" '(tab-next :which-key "next tab")
      "<SPC><left>" '(tab-next :which-key "next tab")
      "<SPC><up>" '(tab-new :which-key "new tab")
      "<SPC><down>" '(tab-close :which-key "close tab")
      "<SPC>s" '(tab-switch :which-key "switch to tab")

      "d" '(:ignore p :which-key "documentation")
      "dd" '(eldoc-doc-buffer :Which-key "open full documentation for point")


      "p" '(:ignore p :which-key "project")
      "pp" '(consult-project-extra-find :which-key "open file in project")
      "po" '(consult-project-extra-find-other-window :which-key "open file other window")
      "ps" '(project-switch-project :which-key "switch project")
      "pb" '(consult-project-buffer :which-key "switch buffer")

      "e" '(:ignore e :which-key "shells")
      "ee" '(project-eshell :which-key "open eshell in project")
      "en" '(jae/eshell-new :which-key "open a new eshell instance")
      "et" '(multi-vterm-project :which-key "open vterm in project")
      "ey" '(multi-vterm :which-key "open new vterm instance ")

      "s" '(:ignore s :which-key "search")
      "ss" '(consult-line :which-key "search buffer")
      "sa" '(consult-ripgrep :which-key "search project")

      "g" '(:ignore g :which-key "magit")
      "gg" '(magit-status :which-key "magit status")
      "gd" '(magit-dispatch :which-key "magit dispatch")
      "gf" '(magit-file-dispatch :which-key "magit file dispatch")

      "w" '(whitespace-cleanup :which-key "whitespace cleanup")
      "b" '(previous-buffer :which-key "previous buffer")
      "f" '(next-buffer :which-key "next buffer")

      "o" '(:ignore o :which-key "orgmode")
      ;"oa" '(counsel-projectile-org-agenda :which-key "org agenda")
      ;"ot" '(counsel-projectile-org-capture :which-key "task capture")
      "on" '(org-narrow-to-subtree :which-key "narrow to subtree")
      "ow" '(widen :which-key "widen buffer to remove narrowing")

      "n" '(:ignore n :which-key "org-roam")
      "nf" '(org-roam-node-find :which-key "roam node find")
      "nr" '(org-roam-node-random :which-key "go to random node")
      "ni" '(org-roam-node-insert :which-key "insert roam node")
      "no" '(org-id-get-create :which-key "create org id")
      "nt" '(org-roam-tag-add :which-key "add roam tag")
      "na" '(org-roam-alias-add :which-key "add roam alias")
      "nl" '(org-roam-buffer-toggle :which-key "toggle the roam buffer")
     )
  #+END_SRC
*** General key bindings
  #+BEGIN_SRC elisp
    (general-define-key
     "C-=" 'text-scale-increase
     "C--" 'text-scale-decrease
     "C-a" 'embark-act
     "C-c C-p" 'wgrep-change-to-wgrep-mode
    )
    (general-define-key
     :keymaps 'normal
     "<right>" 'string-inflection-all-cycle
     )
  #+END_SRC
** Org mode packages
*** Org mode itself
   #+BEGIN_SRC elisp
     (defun jae/configure-org-mode ()
       "Configure 'org-mode'."
       (org-indent-mode)
       (variable-pitch-mode 1)
       (visual-line-mode 1)
       (mapc
         (lambda (face)
                 (set-face-attribute face nil :inherit 'fixed-pitch))
         (list 'org-code
               'org-link
               'org-todo
               'org-block
               'org-table
               'org-verbatim
               'org-block-begin-line
               'org-block-end-line
               'org-meta-line
               'org-document-info-keyword)
         )
      )

     (use-package org
       :hook (org-mode . jae/configure-org-mode)
       :custom-face
       (variable-pitch ((t (:family "ETBembo", :height 180 :weight thin))))
       (fixed-pitch ((t (:family "JetBrainsMono Nerd Font" :height 160))))
       (org-document-title ((t (:weight bold :height 1.5))))
       (org-done ((t (:strike-through t :weight bold))))
       (org-headline-done ((t (:strike-through t))))
       (org-level-1 ((t (:weight bold :height 1.75))))
       (org-level-2 ((t (:weight normal :height 1.5))))
       (org-level-3 ((t (:weight normal :height 1.25))))
       (org-level-4 ((t (:weight normal :height 1.1))))
       (org-level-5 ((t (:weight normal :height 1.0))))
       (org-level-6 ((t (:weight normal :height 1.0))))
       (org-level-7 ((t (:weight normal :height 1.0))))
       (org-level-8 ((t (:weight normal :height 1.0))))
       (org-image-actual-width '(600))
       :init
       (setq org-log-done 'time
             org-log-reschedule 'time
             org-crypt-key "0x45FEBADDA16B8E55"
             org-src-fontify-natively t
             org-ellipsis "  "
             org-pretty-entities t
             org-hide-emphasis-markers t
             org-agenda-block-separator ""
             org-src-fontify-natively t
             org-fontify-whole-heading-line t
             org-fontify-done-headline t
             org-fontify-quote-and-verse-blocks t
             org-agenda-files '("~/Development/org-agenda/" "~/.gcal-org-sync/")
             org-directory '("~/Development/org/")
             org-agenda-todo-list-sublevels 1
             org-agenda-todo-ignore-scheduled t
             org-enforce-todo-dependencies t
             org-startup-with-beamer-mode t
             org-startup-indented t
             org-export-coding-system 'utf-8
             org-export-with-sub-superscripts '{}
             org-agenda-sorting-strategy
              (quote
               ((agenda deadline-up priority-down)
                (todo priority-down category-keep)
                (tags priority-down category-keep)
                (search category-keep)))
             org-todo-keywords
              '((sequence "TODO" "IN-PROGRESS" "WAITING" "|" "DONE" "CANCELED"))
             org-capture-templates
             '(
               ("a" "My TODO task format."
               entry (file "~/Development/org-agenda/todo.org")
               "* TODO %?\n")
               )
       )
       :config
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((R . t)
          (emacs-lisp . t)
          (ruby . t)
          (python . t)
          (js . t)
          (java . t)
          (latex . t)
          (haskell . t)
          (clojure . t)
          ;;(go . t)
          (shell . t)
          (sql . t)
          (sqlite . t)
          (groovy . t)
     ;;(kotlin . t)
          (typescript . t)
          (calc . t)
          (C . t)))
     )
   #+END_SRC

       Define some org-mode keybindings.
   #+BEGIN_SRC elisp
     (general-define-key
      :prefix "C-c"
      "C-r" 'verb-command-map
     )
   #+END_SRC
*** Org -> Hugo
  #+BEGIN_SRC elisp
   (use-package ox-hugo
    :after ox)
  #+END_SRC
*** Org -> Github flavored markdown
  #+BEGIN_SRC elisp
   (use-package ox-gfm
    :after org)
  #+END_SRC
*** Org bullets - uses different utf8 characters for different bullet nesting levels, see: [[https://github.com/sabof/org-bullets][sabof/org-bullets]]
   #+BEGIN_SRC elisp
   (use-package org-bullets
    :hook (org-mode . org-bullets-mode))
   #+END_SRC
*** Org tree slide - presentation mode for org, see: [[https://github.com/takaxp/org-tree-slide][takaxp/org-tree-slide - disabled]]
   #+BEGIN_SRC elisp
   ;;(use-package org-tree-slide
   ;;  :defer
   ;;  :config
   ;;  (define-key org-tree-slide-mode-map (kbd "<f9>") 'org-tree-slide-move-previous-tree)
   ;;  (define-key org-tree-slide-mode-map (kbd "<f10>") 'org-tree-slide-move-next-tree)
   ;;  )
   #+END_SRC
*** Center buffers
   #+BEGIN_SRC elisp
     (use-package visual-fill-column
       :hook (org-mode . visual-fill-column-mode)
       :custom
       (visual-fill-column-width 175)
       (visual-fill-column-center-text t)
     )
   #+END_SRC
** Denote
#+BEGIN_SRC elisp
  (use-package denote
    :init
    (setq denote-directory (expand-file-name "~/Development/denote/"))
    (setq denote-known-keywords '("programming" "organization" "teams" "infrastructure" "devops"))
    (setq denote-file-type nil)
    :hook (dired-mode . denote-dired-mode)
  )
#+END_SRC
** Helpful
 #+BEGIN_SRC elisp
   (use-package helpful
     ;;:custom
     ;;(counsel-describe-function-function #'helpful-callable)
     ;;(counsel-describe-variable-function #'helpful-variable)
     :bind
     ;;([remap describe-function] . counsel-describe-function)
     ([remap describe-command] . helpful-command)
     ;;([remap describe-variable] . counsel-describe-variable)
     ([remap describe-key] . helpful-key)
    )
 #+END_SRC
** Evil Packages - Vim for emacs.
*** Evil itself
   #+BEGIN_SRC elisp
                    (use-package evil
                      :init
                      (setq evil-undo-system 'undo-redo
                            evil-want-keybinding nil
                            evil-want-integration t
                            evil-want-C-i-jump nil
                      )
                      :config
                      (evil-mode 1)
                      (general-define-key
                       :keymaps 'evil-insert-state-map
                       "C-g" 'evil-normal-state
                       )
                    )
   #+END_SRC
*** Evil collection - evil keybindings for different parts of Emacs and packages
   #+BEGIN_SRC elisp
     (use-package evil-collection
       :after evil
       :config
       (setq evil-collection-company-use-tng nil) ;; breaks esh-autosuggest
       (evil-collection-init)
     )
   #+END_SRC
*** Evil org
   #+BEGIN_SRC elisp
     (use-package evil-org
       :after org
       :hook (org-mode . evil-org-mode)
       :config
       (require 'evil-org-agenda)
       (evil-org-agenda-set-keys)
     )
   #+END_SRC
** Theming
*** All the icons for doom modeline
   #+BEGIN_SRC elisp
     (use-package all-the-icons)
   #+END_SRC
*** Doom themes
   #+BEGIN_SRC elisp
     (use-package doom-themes)
   #+END_SRC
*** Doom modeline
   #+BEGIN_SRC elisp
     (use-package doom-modeline
       :init
       (setq doom-modeline-icon 1)
       :config
       (doom-modeline-mode)
       )
   #+END_SRC
*** Tao Theme
  #+BEGIN_SRC elisp
     (use-package tao-theme)
  #+END_SRC
*** Set default theme
   #+BEGIN_SRC elisp
     (defvar jae:theme 'doom-oceanic-next)
     (load-theme jae:theme t)
   #+END_SRC
** Term
*** Enable nicer colors - broken, disabled
   #+BEGIN_SRC elisp
   ;;  (use-package eterm-256color
   ;;    :hook (term-mode . eterm-256color-mode))
   #+END_SRC
** EShell
*** Settings
  #+BEGIN_SRC elisp
    (defun jae/configure-eshell ()
      (require 'em-smart)
      (require 'em-tramp)
      (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)
      ;; Better performance
      (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)
      (general-define-key
       :states '(normal insert visual)
       :keymaps 'eshell-mode-map
       "C-r" 'consult-history
       "C-l" 'eshell/clear
       "C-u" 'kill-whole-line
       )
      ;;(evil-define-key '(normal insert visual) eshell-mode-map (kbd "C-r") 'counsel-esh-history)
      (evil-normalize-keymaps)
      ;;(define-key eshell-mode-map (kbd "C-l") 'eshell/clear)
      ;;(define-key eshell-mode-map (kbd "C-u") 'kill-whole-line)
    (setq
        eshell-where-to-jump 'begin
        eshell-review-quick-commands nil
        eshell-smart-space-goes-to-end t
        eshell-glob-case-insensitive t
        eshell-scroll-to-bottom-on-input t
        eshell-buffer-shorthand t
        eshell-history-size 10000
        eshell-buffer-maximum-lines 10000
        eshell-hist-ignoredups t
        eshell-cmpl-ignore-case t)
    )
    (use-package eshell
      :hook (eshell-first-time-mode . jae/configure-eshell)
      :config
      (with-eval-after-load 'esh-opt
        (setq eshell-destroy-buffer-when-process-dies t
              eshell-visual-commands '("htop" "fish" "bash" "vim")
         )
        )
     )
  #+END_SRC
*** Aliases
   #+BEGIN_SRC elisp
     (defun eshell/x ()
       (insert "exit")
       (eshell-send-input)
       (delete-window))
     (defun eshell/exit () (eshell/x))
     (defun eshell/e (file) (find-file file))
     (add-hook 'eshell-first-time-mode-hook
          (lambda ()
            (eshell/alias "ll" "ls -lah $*" )
          )
     )
   #+END_SRC
*** Helper functions
   #+BEGIN_SRC elisp
     (defun jae/eshell-new ()
       "Opens a new instance of eshell."
       (interactive)
       (eshell 'N))

     (defun jae/eshell-here ()
       "Opens up a new shell in the directory associated with the
     current buffer's file. The eshell is renamed to match that
     directory to make multiple eshell windows easier."
       (interactive)
       (let* ((parent (if (buffer-file-name)
                          (file-name-directory (buffer-file-name))
                        default-directory))
              (height (/ (window-total-height) 3))
              (name   (car (last (split-string parent "/" t)))))
         (split-window-vertically (- height))
         (other-window 1)
         (eshell "new")
         (rename-buffer (concat "*eshell: " name "*"))

         (insert (concat "ls"))
         (eshell-send-input)))

     (defun jae/is-inside-git-tree ()
       "Returns true if inside git work tree."
       (string= (jae/shell-command-to-string-nows "git rev-parse --is-inside-work-tree 2>/dev/null")
                    "true"
                    ))

     (defun jae/git-unpushed-commits ()
       "Returns number of local commits not pushed."
       (if (jae/is-inside-git-tree)
           (let ((
                  changes (jae/shell-command-to-string-nows "git log @{u}.. --oneline 2> /dev/null | wc -l")
                  ))
             (if (string= changes "0")
                 nil
               changes
               )
             )
         nil
         )
       )

     (defun jae/git-changes ()
       "Returns number of changes or nil."
       (if (jae/is-inside-git-tree)
           (let ((
                  diffs (jae/shell-command-to-string-nows "git diff-index HEAD 2> /dev/null | wc -l")
                  ))
             (if (string= diffs "0")
                 nil
               diffs
               )
             )
         nil
         )
       )

     (defun jae/k8s-context ()
       "Return k8s context or nil"
       (let ((
              k8s-ctx (jae/shell-command-to-string-nows
                       "kubectl config current-context 2>/dev/null")
                      ))
         (if (string= k8s-ctx "")
             nil
           k8s-ctx
           )
         )
       )

     (defun jae/k8s-ns ()
       "Return k8s ns or nil"
       (let ((
              k8s-ns (jae/shell-command-to-string-nows
                       "kubens -c 2>/dev/null")
                      ))
         (if (string= k8s-ns "")
             nil
           k8s-ns
           )
         )
       )

     (defun jae/current-gcloud-project ()
       "Returns the current gcloud project."
       (let ((
              gcloud-project (
                 jae/shell-command-to-string-nows
                    "test -e ~/.config/gcloud/configurations/config_default && cat ~/.config/gcloud/configurations/config_default | grep 'project =' | awk '{print $NF}'")
                             ))
         (if (string= gcloud-project "")
             nil
           gcloud-project
           )
         )
       )
   #+END_SRC
*** Prompt
   #+BEGIN_SRC elisp
     (defmacro with-face (STR &rest PROPS)
       "Return STR propertized with PROPS."
       `(propertize ,STR 'face (list ,@PROPS)))

     (defmacro esh-section (NAME ICON FORM &rest PROPS)
       "Build eshell section NAME with ICON prepended to evaled FORM with PROPS."
       `(setq ,NAME
              (lambda () (when ,FORM
                      (-> ,ICON
                         (concat esh-section-delim ,FORM)
                         (with-face ,@PROPS))))))

     (defun esh-acc (acc x)
       "Accumulator for evaluating and concatenating esh-sections."
       (--if-let (funcall x)
           (if (s-blank? acc)
               it
             (concat acc esh-sep it))
         acc))

     (defun esh-prompt-func ()
       "Build `eshell-prompt-function'"
       (concat esh-header
               (-reduce-from 'esh-acc "" eshell-funcs)
               "\n"
               eshell-prompt-string))

     (esh-section esh-dir
                  "\xf07c"  ;  (fontawesome folder)
                  (abbreviate-file-name (eshell/pwd))
                  '(:foreground "#81a1c1" :bold ultra-bold))

       (esh-section esh-git
                  "\xf126"  ;  (git icon)
                  (magit-get-current-branch)
                  '(:foreground "#5e81ac"))

       (esh-section esh-git-changes
                  "\xf071"  ;  (warn icon)
                  (jae/git-changes)
                  '(:foreground "#bf616a"))

       (esh-section esh-git-unpushed-commits
                  "\xf714"  ;  (skull icon)
                  (jae/git-unpushed-commits)
                  '(:foreground "#bf616a"))

       (esh-section esh-k8s
                  "\xf1b3 "  ;  (cubes icon)
                  (format "%s (%s)" (jae/k8s-context) (jae/k8s-ns))
                  '(:foreground "#5e81ac"))

       (esh-section esh-gcp
                  "\xf1a0"  ;  (google icon)
                  (jae/current-gcloud-project)
                  '(:foreground "#5e81ac"))

     ;; Separator between esh-sections
     (setq esh-sep "  ")

     ;; Separator between an esh-section icon and form
     (setq esh-section-delim " ")

     ;; Eshell prompt header
     (setq esh-header "\n")

     ;; Eshell prompt regexp and string. Unless you are varying the prompt by eg.
     ;; your login, these can be the same.
     (setq eshell-prompt-regexp "❯❯ ")
     (setq eshell-prompt-string "❯❯ ")

     ;; Choose which eshell-funcs to enable
     (setq eshell-funcs (list esh-dir esh-git
                              esh-git-changes
                              esh-git-unpushed-commits
                              esh-k8s esh-gcp
                              ))

     ;; Enable the new eshell prompt
     (setq eshell-prompt-function 'esh-prompt-func)
   #+END_SRC
*** Auto suggestions a la fish
   #+BEGIN_SRC elisp
   (use-package esh-autosuggest
     :hook (eshell-mode . esh-autosuggest-mode))
   #+END_SRC

*** Fish shell completion
   #+BEGIN_SRC elisp
   (use-package fish-completion
     :config
     (global-fish-completion-mode)
   )
   #+END_SRC
** Consult
#+BEGIN_SRC elisp
  (use-package consult
  ;; Replace bindings. Lazily loaded due by `use-package'.
  :bind (;; C-c bindings (mode-specific-map)
         ("C-c h" . consult-history)
         ("C-c m" . consult-mode-command)
         ("C-c k" . consult-kmacro)
         ;; C-x bindings (ctl-x-map)
         ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
         ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
         ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
         ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
         ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
         ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
         ;; Custom M-# bindings for fast register access
         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
         ("C-M-#" . consult-register)
         ;; Other custom bindings
         ("M-y" . consult-yank-pop)                ;; orig. yank-pop
         ("<help> a" . consult-apropos)            ;; orig. apropos-command
         ;; M-g bindings (goto-map)
         ("M-g e" . consult-compile-error)
         ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
         ("M-g g" . consult-goto-line)             ;; orig. goto-line
         ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
         ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ;; M-s bindings (search-map)
         ("M-s d" . consult-find)
         ("M-s D" . consult-locate)
         ("M-s g" . #'(consult-grep (project-current)))
         ("M-s G" . #'(consult-git-grep (project-current)))
         ("M-s r" . #'(consult-ripgrep (project-current)))
         ("M-s l" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s m" . consult-multi-occur)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ;; Isearch integration
         ("M-s e" . consult-isearch-history)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
         ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
         ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
         ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
         ;; Minibuffer history
         :map minibuffer-local-map
         ("M-s" . consult-history)                 ;; orig. next-matching-history-element
         ("M-r" . consult-history))                ;; orig. previous-matching-history-element

  ;; Enable automatic preview at point in the *Completions* buffer. This is
  ;; relevant when you use the default completion UI.
  :hook (completion-list-mode . consult-preview-at-point-mode)

  ;; The :init configuration is always executed (Not lazy)
  :init

  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)

  ;; Optionally tweak the register preview window.
  ;; This adds thin lines, sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; Configure other variables and modes in the :config section,
  ;; after lazily loading the package.
  :config

  ;; Optionally configure preview. The default value
  ;; is 'any, such that any key triggers the preview.
  ;; (setq consult-preview-key 'any)
  ;; (setq consult-preview-key (kbd "M-."))
  ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
  ;; For some commands and buffer sources it is useful to configure the
  ;; :preview-key on a per-command basis using the `consult-customize' macro.
  (consult-customize
   consult-theme
   :preview-key '(:debounce 0.2 any)
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file consult-xref
   consult--source-bookmark consult--source-recent-file
   consult--source-project-recent-file
   :preview-key (kbd "M-."))

  ;; Optionally configure the narrowing key.
  ;; Both < and C-+ work reasonably well.
  (setq consult-narrow-key "<") ;; (kbd "C-+")

  ;; Optionally make narrowing help available in the minibuffer.
  ;; You may want to use `embark-prefix-help-command' or which-key instead.
  ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

  ;; By default `consult-project-function' uses `project-root' from project.el.
  ;; Optionally configure a different project root function.
  ;; There are multiple reasonable alternatives to chose from.
  ;;;; 1. project.el (the default)
  ;; (setq consult-project-function #'consult--default-project--function)
  ;;;; 2. projectile.el (projectile-project-root)
  ;;(autoload 'projectile-project-root "projectile")
  ;;(setq consult-project-function (lambda (_) (projectile-project-root)))
  ;;;; 3. vc.el (vc-root-dir)
  ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
  ;;;; 4. locate-dominating-file
  ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
)
#+END_SRC
** Consult project extra
#+BEGIN_SRC elisp
  (use-package consult-project-extra)
#+END_SRC
** Project
The built-in emacs project.el
#+BEGIN_SRC elisp
  ;; I don't do anything but this
  (setq project-switch-commands 'project-find-file)
#+END_SRC
Customize the built-in emacs project.el
#+BEGIN_SRC elisp
  (defcustom project-root-markers
     '("Cargo.toml" "compile_commands.json" "compile_flags.txt"
       "project.clj" ".git" "deps.edn" "shadow-cljs.edn")
     "Files or directories that indicate the root of a project."
     :type '(repeat string)
     :group 'project)

  (defun project-root-p (path)
    "Check if the current PATH has any of the project root markers."
    (catch 'found
      (dolist (marker project-root-markers)
        (when (file-exists-p (concat path marker))
          (throw 'found marker)))))

  (defun project-find-root (path)
  "Search up the PATH for `project-root-markers'."
  (when-let ((root (locate-dominating-file path #'project-root-p)))
    (cons 'transient (expand-file-name root))))

  (add-to-list 'project-find-functions #'project-find-root)
#+END_SRC
** Project Tab Groups
Project tab groups build on top of project and tabs
#+BEGIN_SRC elisp
  (use-package project-tab-groups
   :config
   (project-tab-groups-mode 1))
#+END_SRC
** Embark
#+BEGIN_SRC elisp
  (use-package embark
  ;:bind
  ;(("C-a" . embark-act))         ;; pick some comfortable binding
   ;; ("C-;" . embark-dwim)        ;; good alternative: M-.
   ;; ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init

  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)

  :config

  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :after (embark consult)
  :demand t ; only necessary if you have the hook below
  ;; if you want to have consult previews as you move around an
  ;; auto-updating embark collect buffer
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+END_SRC
** Wgrep
#+BEGIN_SRC elisp
  (setq wgrep-auto-save-buffer t)
  (use-package wgrep)
#+END_SRC
** VTerm - a faster replacement for Term (when you need a real terminal)
*** The vterm package
   When you need a real, reasonably fast terminal.
   #+BEGIN_SRC elisp
     (use-package vterm
       :commands vterm
       :config
       (setq vterm-shell "nu"
                vterm-max-scrollback 10000
        )
      )
   #+END_SRC
*** Multi vterm
   When you need more than one reasonably fast real terminal.
   #+BEGIN_SRC elisp
   (use-package multi-vterm)
   #+END_SRC
** Zoom window - eg. use control-x control-z to zoom in / out a window (eg. "fullscreen" it).
 #+BEGIN_SRC elisp
 (use-package zoom-window
   :bind* ("C-x C-z" . zoom-window-zoom))
 #+END_SRC
** Highlight numbers in source code
 See: [[https://github.com/Fanael/highlight-numbers][https://github.com/Fanael/highlight-numbers]]
 #+BEGIN_SRC elisp
 (use-package highlight-numbers
   :config
   (add-hook 'prog-mode-hook 'highlight-numbers-mode))
 #+END_SRC
** Diff hl - highlight uncommitted changes
 #+BEGIN_SRC elisp
 (use-package diff-hl
   :config
   (setq diff-hl-side 'right)
   (global-diff-hl-mode t)
   ;;(diff-hl-flydiff-mode)
   (add-hook 'after-make-frame-functions(lambda (frame)
     (if (window-system frame)
       (diff-hl-mode)
       (diff-hl-margin-mode))))
   (add-hook 'dired-mode-hook 'diff-hl-dired-mode))
 #+END_SRC
** Magit - the most awesome git editor integration
*** Magit itself
[[https://magit.vc/][  Magit]] is possibly the most awesome git integration of any editor out there.
   #+BEGIN_SRC elisp
   (use-package magit
     :config
     (setq magit-auto-revert-mode nil
              magit-repository-directories
                '( "~/Development" ))
     (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
     :custom
     (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
     )
   #+END_SRC
*** Libgit for better performance
   #+BEGIN_SRC elisp
     (use-package libgit)
     (use-package magit-libgit
       :after (magit libgit))
   #+END_SRC
*** The stupidly named forge package for github/gitlab integration
   #+BEGIN_SRC elisp
   (use-package forge
     :after magit)
   #+END_SRC
** History
#+BEGIN_SRC elisp
  (use-package savehist
    :init
    (savehist-mode))
#+END_SRC
** Vertico
#+BEGIN_SRC elisp
  (use-package vertico
  :bind (:map vertico-map
         ("C-j" . vertico-next)
         ("C-k" . vertico-previous)
         ("C-f" . vertico-exit)
         :map minibuffer-local-map
         ("M-h" . backward-kill-word))
  :custom
  (vertico-cycle t)
  :init
  (setq completion-in-region-function
        (lambda (&rest args)
          (apply (if vertico-mode
                     #'consult-completion-in-region
                   #'completion--in-region)
                 args)))
  (vertico-mode))

  (use-package emacs
    :init
    ;; Add prompt indicator to `completing-read-multiple'.
    ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
    (defun crm-indicator (args)
      (cons (format "[CRM%s] %s"
                    (replace-regexp-in-string
                     "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                     crm-separator)
                    (car args))
            (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
    ;; Vertico commands are hidden in normal buffers.
    ;; (setq read-extended-command-predicate
    ;;       #'command-completion-default-include-p)

    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t))
#+END_SRC
** Marginalia
#+BEGIN_SRC elisp
  (use-package marginalia
    :after vertico
    :custom
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    :init
    (marginalia-mode))
#+END_SRC
** Orderless
#+BEGIN_SRC elisp
  (use-package orderless
    :init
    ;; Configure a custom style dispatcher (see the Consult wiki)
    ;; (setq orderless-style-dispatchers '(+orderless-dispatch)
    ;;       orderless-component-separator #'orderless-escapable-split-on-space)
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))
#+END_SRC
** Which key
 Which key will show any possible continuations of a currently entered incomplete command.
 See: [[https://github.com/justbur/emacs-which-key][https://github.com/justbur/emacs-which-key]]
 #+BEGIN_SRC elisp
 (use-package which-key
   :config
   (which-key-mode)
   (which-key-setup-side-window-bottom)
   (setq which-key-sort-order 'which-key-key-order-alpha
         which-key-side-window-max-width 0.33
         which-key-idle-delay 0.05)
   )
 #+END_SRC
** Fringe helper
 Helper functions for generating fringe bitmaps, also comes with some "stock" ones.
 #+BEGIN_SRC elisp
 (use-package fringe-helper
   :init
   (setq-default left-fringe-width  16)
   (setq-default right-fringe-width 16)
 )
 #+END_SRC
** Hydra
 Hydra is a really cool package allowing you to temporarily enable some keybindings with an optional timeout. Hard to explain WHY that is cool, trust me - it is.
*** The package
   #+BEGIN_SRC elisp
     (use-package hydra)
   #+END_SRC
*** Text scaling
   #+BEGIN_SRC elisp
     (defhydra hydra-text-scale (:timeout 4)
       "scale text"
       ("j" text-scale-increase "in")
       ("k" text-scale-decrease "out")
       ("f" nil "finished" :exit t)
     )
     (jae/leader-keys
        "ts" '(hydra-text-scale/body :which-key "scale text")
      )
   #+END_SRC
*** Term switching
   #+BEGIN_SRC elisp
     (defhydra hydra-term-switch (:timeout 4)
       "switch term"
       ("j" multi-vterm-prev "prev")
       ("k" multi-vterm-next "next")
       ("f" nil "finished" :exit t)
     )
     (jae/leader-keys
        "es" '(hydra-term-switch/body :which-key "cycle through terminals")
      )
   #+END_SRC
** VERB http client
 #+BEGIN_SRC elisp
 (use-package verb)
 #+END_SRC
** Programming and markup languages
*** LSP Mode
   Language Server Protocol.
   See: [[https://github.com/emacs-lsp/lsp-mode][emacs-lsp/lsp-mode]]
 #+BEGIN_SRC elisp
   (use-package lsp-mode
     :init
     (setq lsp-keymap-prefix "C-c a"
           lsp-prefer-capf t
           lsp-rust-server 'rust-analyzer)
     :config
     (setq lsp-prefer-flymake nil)
     (setq lsp-enable-snippet nil)
     (add-to-list 'lsp-language-id-configuration '(nix-mode . "nix"))
     (lsp-register-client
      (make-lsp-client :new-connection (lsp-stdio-connection '("rnix-lsp"))
                       :major-modes '(nix-mode)
                       :server-id 'nix))
     (setq lsp-file-watch-ignored '(
       "[/\\\\]\\.direnv$"
       ; SCM tools
       "[/\\\\]\\.git$"
       "[/\\\\]\\.hg$"
       "[/\\\\]\\.bzr$"
       "[/\\\\]_darcs$"
       "[/\\\\]\\.svn$"
       "[/\\\\]_FOSSIL_$"
       ; IDE tools
       "[/\\\\]\\.idea$"
       "[/\\\\]\\.ensime_cache$"
       "[/\\\\]\\.eunit$"
       "[/\\\\]node_modules$"
       "[/\\\\]\\.fslckout$"
       "[/\\\\]\\.tox$"
       "[/\\\\]\\.stack-work$"
       "[/\\\\]\\.bloop$"
       "[/\\\\]\\.metals$"
       "[/\\\\]target$"
       ; Autotools output
       "[/\\\\]\\.deps$"
       "[/\\\\]build-aux$"
       "[/\\\\]autom4te.cache$"
       "[/\\\\]\\.reference$"))
     :hook (
       (lsp-mode . lsp-enable-which-key-integration)
       (prog-mode . lsp-mode)
     )
     :custom
     (lsp-rust-analyzer-cargo-watch-command "clippy")
     (lsp-eldoc-render-all t)
     (lsp-idle-delay 0.6)
     (lsp-rust-analyzer-server-display-inlay-hints t)
     (lsp-terraform-server '("terraform-ls" "serve"))
   )

   (use-package lsp-ui
     :after lsp-mode
     :config
     (setq lsp-ui-doc-max-height 60)
     :hook
     (
       (lsp-mode . lsp-ui-mode)
     )
     :custom
     (lsp-ui-peek-always-show t)
     (lsp-ui-sideline-show-hover t)
   )

   ;;(use-package lsp-ivy :commands lsp-ivy-workspace-symbol)
 #+END_SRC
*** Flycheck mode
**** The mode itself
     On-the-fly syntax checking, see: [[https://www.flycheck.org/en/latest/][https://www.flycheck.org/en/latest/]]
     #+BEGIN_SRC elisp
        (use-package flycheck
          :config
          (global-flycheck-mode)
          (setq flycheck-idle-change-delay 2.0)
        )
     #+END_SRC
**** Flycheck popups - error display
***** Popup tip
       For showing errors in terminal (pos-tip doesn't do that - see below).
       See: [[https://github.com/flycheck/flycheck-popup-tip][https://github.com/flycheck/flycheck-popup-tip]]
       #+BEGIN_SRC elisp
       (use-package flycheck-popup-tip)
       #+END_SRC
***** Pos tip
       For showing errors under point. Refers to above for similar terminal functionality.
       See: [[https://github.com/flycheck/flycheck-pos-tip][https://github.com/flycheck/flycheck-pos-tip]]
       #+BEGIN_SRC elisp
       (use-package flycheck-pos-tip
         :config
         (setq flycheck-pos-tip-display-errors-tty-function #'flycheck-popup-tip-show-popup)
         (setq flycheck-pos-tip-timeout 0)
         (flycheck-pos-tip-mode))
       #+END_SRC
*** Tree-sitter
   Tree sitter provides better syntax highlighting.
   #+BEGIN_SRC elisp
     (use-package tree-sitter
       :hook (((
               ruby-mode
               js-mode
               typescript-mode
               rustic-mode
               toml-mode
               shell-mode
               go-mode
             ) . tree-sitter-mode)
             ((
               ruby-mode
               js-mode
               typescript-mode
               rustic-mode
               toml-mode
               shell-mode
               go-mode
             ) . tree-sitter-hl-mode)
             )
     )
     (use-package tree-sitter-langs
       :after tree-sitter
     )
   #+END_SRC
*** Rust
**** Rustic
     #+BEGIN_SRC elisp
       (use-package rustic
         :mode ("\\.rs$" . rustic-mode)
         :bind (:map rustic-mode-map
                     ("C-c C-c j" . lsp-ui-imenu)
                     ("C-c C-c p" . lsp-find-references)
                     ("C-c C-c l" . flycheck-list-errors)
                     ("C-c C-c a" . lsp-execute-code-action)
                     ("C-c C-c r" . lsp-rename)
                     ("C-c C-c q" . lsp-workspace-restart)
                     ("C-c C-c Q" . lsp-workspace-shutdown)
                     ("C-c C-c s" . lsp-rust-analyzer-status))
         :config
         (setq rustic-format-on-save t)
         (add-hook 'rustic-mode-hook 'jae/rustic-mode-hook))

       (defun jae/rustic-mode-hook ()
         ;; make C-c C-c C-r work without confirmation
         (setq-local buffer-save-without-query t))
     #+END_SRC
*** Markdown mode
   #+BEGIN_SRC elisp
   (use-package markdown-mode)
   #+END_SRC
*** Company mode
[[https://company-mode.github.io/][ Company]] is a text completion framework for Emacs. The name stands for "complete anything". It uses pluggable back-ends
  and front-ends to retrieve and display completion candidates.
  It comes with several back-ends such as Elisp, Clang, Semantic, Eclim, Ropemacs, Ispell, CMake, BBDB, Yasnippet, dabbrev,
  etags, gtags, files, keywords and a few others.
  #+BEGIN_SRC elisp
  (use-package company
    :init
    (setq company-idle-delay 0.05
          company-echo-delay 0.05
          company-minimum-prefix-length 2
          company-dabbrev-ignore-case nil
          company-dabbrev-downcase nil)
    :config
    (global-company-mode))
  #+END_SRC
*** Company quick help
   Show documentation popups when idling on a completion candidate.
   See: [[https://github.com/expez/company-quickhelp][https://github.com/expez/company-quickhelp]]
   #+BEGIN_SRC elisp
   (use-package company-quickhelp
     :config
     (company-quickhelp-mode 1)
     (setq company-quickhelp-delay 0))
   #+END_SRC
*** Golang
**** Go mode
   #+BEGIN_SRC elisp
     (use-package go-mode
       :config
       (setq gofmt-command "goimports")
       :hook (
              (before-save . gofmt-before-save)
              (go-mode . lsp)
             )
     )
   #+END_SRC
**** Go guru
     #+BEGIN_SRC elisp
     (use-package go-guru
       :config
       (go-guru-hl-identifier-mode))
     #+END_SRC
**** Flycheck Gometalinter
     #+BEGIN_SRC elisp
     (use-package flycheck-gometalinter
       :after flycheck
       :config
       (setq flycheck-gometalinter-fast t
             flycheck-gometalinter-test t
             flycheck-gometalinter-deadlines "10s")
       (progn
         (flycheck-gometalinter-setup)))
     #+END_SRC
**** Go Eldoc
     #+BEGIN_SRC elisp
     (use-package go-eldoc
       :config
       (add-hook 'go-mode-hook 'go-eldoc-setup))
     #+END_SRC

*** Terraform
**** The mode itself
     HashiCorps terraform.
     #+BEGIN_SRC elisp
       (use-package terraform-mode
         :mode "\\.tf$"
         :hook (
                (terraform-mode . terraform-format-on-save-mode)
                (terraform-mode . lsp)
               )
       )
     #+END_SRC
**** Company terraform
     #+BEGIN_SRC elisp
        (use-package company-terraform
          :after company
          :config
          (company-terraform-init))
     #+END_SRC
*** Nix
**** The mode
   #+BEGIN_SRC elisp
     (use-package nix-mode
       :mode "\\.nix$"
       :hook (
              (nix-mode . lsp)
             )
     )
   #+END_SRC
*** Shell
   There's already shell mode. But I use fish shell so it's nice to get some syntax highlighting for that.
   #+BEGIN_SRC elisp
   (use-package fish-mode)
   #+END_SRC
*** Web
   For editing html, css etc.
   See: [[https://github.com/fxbois/web-mode][https://github.com/fxbois/web-mode]]
   #+BEGIN_SRC elisp
   (use-package web-mode
     :mode "\\.html?$")
   #+END_SRC
*** Docker
   You know, for docker.
   #+BEGIN_SRC elisp
    (use-package dockerfile-mode
    :mode "Dockerfile.*")
   #+END_SRC
*** Moonscript
   #+BEGIN_SRC elisp
   (use-package moonscript
     :mode ("\\Spookfile.*\\'" . moonscript-mode))
   #+END_SRC
*** Lua
   #+BEGIN_SRC elisp
     (use-package lua-mode
       :mode "\\.lua$:")
   #+END_SRC
*** Json
   #+BEGIN_SRC elisp
      (use-package json-mode
        :mode (
               ("\\.bowerrc$" . json-mode)
               ("\\.jshintrc$" . json-mode)
               ("\\.json_schema$" . json-mode)
               ("\\.json$'" . json-mode)
              )
        :bind (:package json-mode-map
           :map json-mode-map
               ("C-c <tab>" . json-mode-beautify))
        :config
        (make-local-variable 'js-indent-level)
      )
   #+END_SRC
*** Yaml
   #+BEGIN_SRC elisp
     (use-package yaml-mode
       :mode (
              ("\\.cf$" . yaml-mode)
              ("\\.yml$" . yaml-mode)
              ("\\.yaml$" . yaml-mode)
             )
     )
   #+END_SRC
*** Toml
   #+BEGIN_SRC elisp
     (use-package toml-mode
       :mode (
              ("\\.toml$" . toml-mode)
             )
     )
   #+END_SRC
*** Javascript
**** The mode
     #+BEGIN_SRC elisp
       (use-package js2-mode
         :config
         (setq js2-strict-missing-semi-warning nil)
         (setq js2-missing-semi-one-line-override t)
         (setq js-indent-level 2)
         :mode (
                 ("\\.js$" . js2-mode)
               )
       )
     #+END_SRC
**** Make it pretty
     #+BEGIN_SRC elisp
       (use-package prettier-js
         :hook (
            (js2-mode . prettier-js-mode)
            (typescript-mode . prettier-js-mode)
         )
       )
     #+END_SRC

*** Justfile
**** The mode
     #+BEGIN_SRC elisp
       (use-package just-mode)
     #+END_SRC
** String inflection
#+BEGIN_SRC elisp
  (use-package string-inflection)
#+END_SRC
** Direnv integration
 Direnv integration - per buffer - for emacs.
 See: [[https://github.com/wbolster/emacs-direnv][https://github.com/purcell/envrc]]
 and ofc
 https://direnv.net/
 #+BEGIN_SRC elisp
   (use-package inheritenv
     :config
     (inheritenv-add-advice 'rustic-compilation)
     )
   (use-package envrc
    :init
    (add-hook 'change-major-mode-after-body-hook
      (defun +direnv-init-j ()
        (unless (or envrc-mode
                    (minibufferp)
                    (file-remote-p default-directory))
          (condition-case _
              (envrc-mode 1)
            (quit)))))
   )
 #+END_SRC

** Code formatting
#+BEGIN_SRC elisp
  (use-package apheleia
    :config
    (apheleia-global-mode +1)
    (progn ;; JavaScript/TypeScript
      (cl-pushnew '(eslint . (npx "eslint_d" "--fix-to-stdout" "--stdin" "--stdin-filename" file)) apheleia-formatters :test #'equal))
    (progn ;; Nix
      (cl-pushnew '(alejandra . ("alejandra")) apheleia-formatters :test #'equal)
      (cl-pushnew '(nix-mode . alejandra) apheleia-mode-alist :test #'equal)))
  #+END_SRC



** Use OSC 52 Escape sequence for copying to system clipboard
#+BEGIN_SRC elisp
    (use-package clipetty
     :config
      (when (not (display-graphic-p))
       (add-hook 'after-init-hook
         (lambda ()
           (global-clipetty-mode)
           )
         )
      )
    )
#+END_SRC
